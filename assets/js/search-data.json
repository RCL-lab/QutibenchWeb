{
  
    
        "post0": {
            "title": "Contributing",
            "content": "Add a Machine Learning Benchmark . Steps on how to add your favorite machine learning benchmark . Copy the file data/data_template.csv file and rename it with the name of your machine learning benchmark, e.g. data/imagenet.csv. . | Enter your data in this new .csv file, leaving columns blank if data is not available . | Copy 2020-01-01-Jupyter_benchmark_template.ipynb and rename it in the format yyyy-mm-dd-benchmark_name.ipynb e.g. 2020-01-01-imagenet.ipynb. . | Using jupyter Notebook/Lab, open the new notebook. Update the metadata in the first cell, (categories, title, subtitle) as well as the csv_path variable to point to your new data. If you would like to add an image, include it in the images/ folder of the repo and include a link in the metadata under the image field. . | Run all cells of the notebook (there&#39;s a shortcut for this) and ensure that all plots are displaying as they should. . | Commit your new work in git, and push/open a pull request in the repository. Once changes are merged they will go live on the website within a few minutes. . |",
            "url": "https://rcl-lab.github.io/Qutibench_Web/contributing/meta/2020/04/09/Contributing.html",
            "relUrl": "/contributing/meta/2020/04/09/Contributing.html",
            "date": " • Apr 9, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Rooflines",
            "content": "Just some needed functions . Loading Hardware platforms and Neural networks csv . Overview of the experiments done . filenames = [&#39;Data/imagenet.csv&#39;, &#39;Data/mnist.csv&#39;, &#39;Data/cifar10.csv&#39;] dataframes = load_and_display(filenames) for i in range(len(dataframes)): display(HTML(dataframes[i].to_html(index=False))) . ImageNet Classification . Hardware Platform ResNet50 GoogLeNetV1 MobileNet . FPGA | ZCU102-DPU | [INT8]*[100%,80%,50%,30%] | INT8 | na | . | ZCU104-DPU | INT8 | INT8 | na | . | Ultra96-DPU | [INT8]*[100%,80%,50%,30%] | INT8 | INT8 | . | ZCU104-FINN | na | na | na | . | ZCU104-BISMO | na | na | na | . GPU | TX2-maxn | FP16,FP32 | FP16,FP32 | na | . | TX2-maxp | FP16,FP32 | FP16,FP32 | na | . | TX2-maxq | FP16,FP32 | FP16,FP32 | na | . TPU | TPU-fast clk | na | INT8 | INT8 | . | TPU-slow clk | na | INT8 | INT8 | . VLIW | NCS | FP16 | na | na | . CPU | U96-Quadcore A53 | na | na | na | . MNIST Classification . Hardware Platform MLP . FPGA | ZCU102-DPU | na | . | ZCU104-DPU | na | . | Ultra96-DPU | na | . | ZCU104-FINN | [INT2, INT4] * [100%,50%,25%,12.5%] | . | ZCU104-BISMO | [INT2, INT4] * [100%,50%,25%,12.5%] | . GPU | TX2-maxn | [FP16, FP32] * [100%,50%,25%,12.5%] | . | TX2-maxp | [FP16, FP32] * [100%,50%,25%,12.5%] | . | TX2-maxq | [FP16, FP32] * [100%,50%,25%,12.5%] | . TPU | TPU-fast clk | na | . | TPU-slow clk | na | . VLIW | NCS | [FP16] * [100%,50%,25%,12.5%] | . CPU | U96-Quadcore A53 | [INT2, INT4] * [100%,50%,25%,12.5%] | . CIFAR10 Classification . Hardware Platform CNV . FPGA | ZCU102-DPU | na | . | ZCU104-DPU | na | . | Ultra96-DPU | na | . | ZCU104-FINN | [INT2,INT4]*[100%,50%,25%,12.5%] | . | ZCU104-BISMO | [INT2,INT4]*[100%,50%,25%,12.5%] | . GPU | TX2-maxn | [FP16,FP32]*[100%,50%,25%,12.5%] | . | TX2-maxp | [FP16,FP32]*[100%,50%,25%,12.5%] | . | TX2-maxq | [FP16,FP32]*[100%,50%,25%,12.5%] | . TPU | TPU-fast clk | na | . | TPU-slow clk | na | . VLIW | NCS | [FP16]*[100%,50%,25%,12.5%] | . CPU | U96-Quadcore A53 | [INT2,INT4]*[100%,50%,25%,12.5%] | . Calculate the Arithmetic intensity (x axis) for each NN based on Fwd ops and Total params . df_topology.head() . Name arith_intens . 0 MobileNet V1 | 23878 | . 1 AlexNet | 2995 | . 2 GoogLeNet V1 | 29988 | . 3 ResNet-18 | 39950 | . 4 ResNet-34 | 43169 | . df.head() . Name Peak_Performance Bandwidth . 0 Ultra96 DPU INT8 | 0.96 | 0.00426 | . 1 ZCU104 INT8 | 4.60 | 0.01920 | . 2 ZCU102 INT8 | 6.71 | 0.01920 | . 3 ZCU104 FINN INT2 | 30.70 | 0.01920 | . 4 ZCU104 FINN INT4 | 8.80 | 0.01920 | . Preparing the NNs dataset to be ploted as vertical lines later . Calculating the rooflines (y axis) for each hardware platform (dataframe = df_topology + df) . dataframe.head() . Name arith_intens performance . 0 Ultra96 DPU INT8 | 1 | 0.00426 | . 1 Ultra96 DPU INT8 | 226.1 | 0.96000 | . 2 Ultra96 DPU INT8 | 160000 | 0.96000 | . 3 ZCU104 INT8 | 1 | 0.01920 | . 4 ZCU104 INT8 | 240.1 | 4.60000 | . Merging NNs dataset with Hardware Platforms dataset . Plotting Rooflines and NNs Arithmetic intensity with legend selecting each desired plott . sel = alt.selection_multi(fields=[&quot;Name&quot;], bind=&quot;legend&quot;) alt.Chart(data=dataframe, width=700,height=500).add_selection(sel).mark_line(clip=True).interactive().properties(title=&#39;Comparing Hardware Platforms Rooflines and Neural Networks Arithmetic Intensity &#39;).encode( alt.X(&#39;arith_intens:Q&#39;, title = &#39;ARITHMETIC INTENSITY (OPS/BYTE)&#39;, scale = alt.Scale(type=&#39;log&#39;, domain = (0.1,maxX) ) ), alt.Y(&#39;performance:Q&#39;, title = &#39;PERFORMANCE (TOPS/S)&#39;, scale=alt.Scale(type=&#39;log&#39;, domain = (0.2,40) ) ), color = alt.condition(sel, alt.Color(&#39;Name:N&#39;,legend=alt.Legend(columns=2)), alt.value(&#39;lightgrey&#39;)) ) . # The basic line plot sel = alt.selection_multi(fields=[&quot;Name&quot;], bind=&quot;legend&quot;) alt.Chart(data=dataframe, width=700,height=500).add_selection(sel).mark_line(clip=True).interactive().properties(title=&#39;Comparing Hardware Platforms Rooflines and Neural Networks Arithmetic Intensity &#39;).encode( alt.X(&#39;arith_intens:Q&#39;, title = &#39;ARITHMETIC INTENSITY (OPS/BYTE)&#39;, scale = alt.Scale(type=&#39;log&#39;, domain = (0.1,maxX) ) ), alt.Y(&#39;performance:Q&#39;, title = &#39;PERFORMANCE (TOPS/S)&#39;, scale=alt.Scale(type=&#39;log&#39;, domain = (0.2,40) ) ), color = alt.condition(sel, alt.Color(&#39;Name:N&#39;,legend=alt.Legend(columns=6)), alt.value(&#39;lightgrey&#39;)) ) . Plotting Rooflines and NNs Arithmetic intensity: line plot overlapped with point plot . # The basic line plot chart = alt.Chart(data=dataframe, width=700,height=500).properties(title=&#39;Comparing Hardware Platforms Rooflines and Neural Networks Arithmetic Intensity &#39;).encode( alt.X(&#39;arith_intens:Q&#39;, title = &#39;ARITHMETIC INTENSITY (OPS/BYTE)&#39;, scale = alt.Scale(type=&#39;log&#39;, domain = (0.1,maxX) ) ), alt.Y(&#39;performance:Q&#39;, title = &#39;PERFORMANCE (TOPS/S)&#39;, scale=alt.Scale(type=&#39;log&#39;, domain = (0.2,40) ) ), color = &#39;Name:N&#39;, tooltip = [alt.Tooltip(&#39;Name:N&#39;), alt.Tooltip(&#39;arith_intens:Q&#39;), alt.Tooltip(&#39;performance:Q&#39;) ] ) chart.mark_line(clip=True) + chart.mark_point(clip=True) . Plotting Rooflines and NNs Arithmetic intensity with drop-down . selection = alt.selection_single( name = &#39;Select&#39;, fields = [&#39;Name&#39;], init = {&#39;Name&#39;: &#39;Ultra96 DPU INT8&#39;}, #selecionar o grafico que e para ser mostrado como oprimeiro/default bind = {&#39;Name&#39;: alt.binding_select(options=dataframe[&#39;Name&#39;].unique().tolist())} ) # The basic line plot alt.Chart(data=dataframe, width=700,height=500).mark_line(clip=True).properties(title=&#39;Comparing Hardware Platforms Rooflines and Neural Networks Arithmetic Intensity. Drop-down chart&#39;).add_selection(selection).encode( alt.X(&#39;arith_intens:Q&#39;, title = &#39;ARITHMETIC INTENSITY (OPS/BYTE)&#39;, scale = alt.Scale(type=&#39;log&#39;, domain = (0.1,maxX) ) ), alt.Y(&#39;performance:Q&#39;, title = &#39;PERFORMANCE (TOPS/S)&#39;, scale=alt.Scale(type=&#39;log&#39;, domain = (0.2,40) ) ), color=&#39;Name:N&#39;, opacity = alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Plotting Rooflines and NNs Arithmetic intensity with checkboxes . Plotting Rooflines and NNs Arithmetic intensity: interactive boxes as legend . make = pd.DataFrame({&#39;Name&#39;: dataframe.Name.unique()}) selection = alt.selection_multi(fields=[&#39;Name&#39;]) color = alt.condition(selection, alt.Color(&#39;Name:N&#39;, legend = None), alt.value(&#39;lightgray&#39;)) make_selector = alt.Chart(make).mark_rect().encode( y=&#39;Name&#39;, color=color ).add_selection(selection) fuel_chart = alt.Chart(dataframe, width = 700, height=500).mark_line(clip=True).encode( alt.X(&#39;arith_intens:Q&#39;, title = &#39;ARITHMETIC INTENSITY (OPS/BYTE)&#39;, scale = alt.Scale(type=&#39;log&#39;, domain = (0.1,maxX) ) ), y = alt.Y(&#39;performance:Q&#39;, title = &#39;PERFORMANCE (TOPS/S)&#39;, scale=alt.Scale(type=&#39;log&#39;, domain = (0.2,40) ) ), color= alt.Color(&#39;Name:N&#39;, legend = None), ).transform_filter(selection) make_selector | fuel_chart . Plotting Rooflines and NNs Arithmetic intensity: on plot Tooltips . #Adapted from https://stackoverflow.com/questions/53287928/tooltips-in-altair-line-charts # Step 1: create the lines lines = alt.Chart().mark_line(clip=True).encode( alt.X(&#39;arith_intens:Q&#39;, title = &#39;ARITHMETIC INTENSITY (OPS/BYTE)&#39;, scale = alt.Scale(type=&#39;log&#39;, domain = (0.1,maxX) ) ), y = alt.Y(&#39;performance:Q&#39;, title = &#39;PERFORMANCE (TOPS/S)&#39;, scale=alt.Scale(type=&#39;log&#39;, domain = (0.2,40) ) ), color=&#39;Name:N&#39; ) # Step 2: Selection that chooses nearest point based on value on x-axis nearest = alt.selection(type=&#39;single&#39;, nearest=True, on=&#39;mouseover&#39;, fields=[&#39;arith_intens&#39;]) #to leave suggestions on, just replace arith_intens wiith anything else # Step 3: Transparent selectors across the chart. This is what tells us # the x-value of the cursor selectors = alt.Chart().mark_point(clip=True).encode( alt.X(&#39;arith_intens:Q&#39;, title = &#39;ARITHMETIC INTENSITY (OPS/BYTE)&#39;, scale = alt.Scale(type=&#39;log&#39;, domain = (0.1,maxX) ) ), y = alt.Y(&#39;performance:Q&#39;, title = &#39;PERFORMANCE (TOPS/S)&#39;, scale=alt.Scale(type=&#39;log&#39;, domain = (0.2,40) ) ), opacity=alt.value(0), ).add_selection( nearest ) # Step 4: Add text, show values in Sex column when it&#39;s the nearest point to # mouseover, else show blank text = lines.mark_text(align=&#39;left&#39;, dx=3, dy=-3,clip=True).encode( text=alt.condition(nearest, &#39;Name:N&#39;, alt.value(&#39; &#39;))) # Layer them all together alt.layer(lines, selectors, text, data=dataframe, width=700, height=500) . HEATMAPS . Reading csv file and converting data to (Neural network, Platform, Value) . df = pd.read_csv(&#39;data/GOPperNN.csv&#39;) df.head() pd.set_option(&#39;display.max_rows&#39;, None) #-- Creating a dataframe with 3 columns x, y gop_frame cleanedList = [x for x in df.platform if x==x] # to take all the nans out x, y = np.meshgrid(df.model, cleanedList) gop_frame, _ = np.meshgrid(df.gop_frame, cleanedList) #to crate a 1D array from each variable, creating a dataframe with 3 columns source = pd.DataFrame({&#39;x&#39;: x.ravel(), &#39;y&#39;: y.ravel(), &#39;gop_frame&#39;:gop_frame.ravel()}) #auxilary column #Adding a fourth column: top_second - auxilary column tops_second= [] #creating a lsit which will contain all top_second columns from the dataframe columns = list(df) # creating a list of dataframe columns for i in columns: if &#39;top_second&#39; in i: tops_second.append(df[i]) source[&#39;top_second&#39;] = pd.concat(tops_second,ignore_index=True) #Adding a fith column: values-- source[&#39;values&#39;] = source.top_second * 1000 / source.gop_frame #Drop auxilary columns: gop_frame top_scond- source = source.drop(columns=[&#39;gop_frame&#39;,&#39;top_second&#39;]) source = source.round(0) source.head() . x y values . 0 GoogleNetv1-INT8 | Ultra96-INT8 | 307.0 | . 1 GoogleNetv1-FP16 | Ultra96-INT8 | NaN | . 2 GoogleNetv1-FP32 | Ultra96-INT8 | NaN | . 3 MobileNetv1-INT8 | Ultra96-INT8 | 842.0 | . 4 ResNet50 100%-INT8 | Ultra96-INT8 | 124.0 | . df_imagenet = source[source[&#39;x&#39;].str.contains(&#39;GoogleNetv|MobileNetv1|ResNet50|EfficientNet&#39;)] df_cifar10 = source[source[&#39;x&#39;].str.contains(&#39;CNV&#39;)] df_MNIST = source[source[&#39;x&#39;].str.contains(&#39;MLP&#39;)] . Heatmap with all models together . middleOfScale = 10000 single_nearest = alt.selection_single(on=&#39;mouseover&#39;, nearest=True) color_selection = color = alt.Color(&#39;values:Q&#39;, title= &#39;Input/second&#39;,scale = alt.Scale(type=&#39;log&#39;, scheme=&#39;lightmulti&#39;)) heatmap = alt.Chart(source, width = 1300, height=350).mark_rect(stroke=&#39;black&#39;, strokeWidth=1, invalid = None).add_selection(single_nearest).properties(title=&#39;Performance predictions for all models&#39;).encode( alt.X(&#39;x:O&#39;, title = &#39;Models&#39;), alt.Y(&#39;y:O&#39;, title = &#39;Hardware Platfroms&#39;), color = alt.condition(single_nearest, alt.value(&#39;lightgrey&#39;), color_selection), tooltip = [alt.Tooltip(&#39;values:Q&#39;, title = &#39;Input/sec&#39;), alt.Tooltip(&#39;x:N&#39;, title = &#39;Model&#39;), alt.Tooltip(&#39;y:N&#39;, title = &#39;Hardware Platform&#39;), ] ) text = alt.Chart(source).mark_text(color = &#39;white&#39;).encode( alt.X(&#39;x:O&#39;, title = &#39;Models&#39;), alt.Y(&#39;y:O&#39;, title = &#39;Hardware Platfroms&#39; ), text = alt.Text(&#39;values:Q&#39;, format = &#39;.0f&#39;), color=alt.condition( #(alt.datum.values &lt; 1) | (alt.datum.values &gt; 1000), (alt.datum.values &gt; 1), alt.value(&#39;black&#39;), alt.value(&#39;white&#39;) ), tooltip = [ alt.Tooltip(&#39;values:Q&#39;, title = &#39;Input/sec&#39;, format = &#39;.3f&#39;), alt.Tooltip(&#39;x:N&#39;, title = &#39;Model&#39;), alt.Tooltip(&#39;y:N&#39;, title = &#39;Hardware Platform&#39;), ] ) alt.layer(heatmap, text) # same as alt.layer heatmap + text . #Function to create a heatmap def heatmap(df, title, color): return alt.Chart(df, width=700, height=350).mark_rect(stroke=&#39;black&#39;, strokeWidth=1, invalid = None).add_selection(single_nearest).properties(title=title).encode( alt.X(&#39;x:O&#39;, title = &#39;Models&#39;), alt.Y(&#39;y:O&#39;, title = &#39;Hardware Platfroms&#39;), color = alt.condition(single_nearest, alt.value(color), color_selection), tooltip = [alt.Tooltip(&#39;values:Q&#39;, title = &#39;Input/sec&#39;), alt.Tooltip(&#39;x:N&#39;, title = &#39;Model&#39;), alt.Tooltip(&#39;y:N&#39;, title = &#39;Hardware Platform&#39;), ] ) . #Function to create a text to sum with heatmap def text(df, color_condition): return alt.Chart(df).mark_text(color = &#39;white&#39;).encode( alt.X(&#39;x:O&#39;, title = &#39;Models&#39;), alt.Y(&#39;y:O&#39;, title = &#39;Hardware Platfroms&#39; ), text = alt.Text(&#39;values:Q&#39;, format = &#39;.0f&#39;), color= color_condition, tooltip = [ alt.Tooltip(&#39;values:Q&#39;, format = &#39;.0f&#39;, title = &#39;Input/sec&#39;), alt.Tooltip(&#39;x:N&#39;, title = &#39;Model&#39;), alt.Tooltip(&#39;y:N&#39;, title = &#39;Hardware Platform&#39;), ] ) . Heatmap for Imagenet classification . #--IMAGENET plot-- middleOfScale = 1000 color_selection = alt.Color(&#39;values:Q&#39;, title = &#39;Input/second&#39;, scale=alt.Scale(type=&#39;log&#39;, scheme = &#39;lightmulti&#39;)) color_condition = alt.condition((alt.datum.values &gt; 1), alt.value(&#39;black&#39;), alt.value(&#39;white&#39;)) ImagenetHeatmap = heatmap(df_imagenet, &#39;Performance predictions for ImageNet&#39;, &#39;lightgrey&#39;) text_i = text(df_imagenet, color_condition) ImagenetHeatmap = ImagenetHeatmap + text_i #-CIFAR 10 plot middleOfScale = 50000 single_nearest = alt.selection_single(on=&#39;mouseover&#39;, nearest=True) color_selection = alt.Color(&#39;values:Q&#39;, title= &#39;Input/second&#39;,scale=alt.Scale(type=&#39;log&#39;, scheme=&#39;lightmulti&#39;)) color_condition=alt.condition(alt.datum.values &gt; 1, alt.value(&#39;black&#39;), alt.value(&#39;white&#39;)) Cifar10Heatmap = heatmap(df_cifar10, &#39;Performance predictions for CIFAR 10&#39;, &#39;pink&#39;) text_c = text(df_cifar10, color_condition) Cifar10Heatmap = Cifar10Heatmap + text_c #-MNIST plot middleOfScale = 50000 single_nearest = alt.selection_single(on=&#39;mouseover&#39;, nearest=True) color_selection = alt.Color(&#39;values:Q&#39;, title= &#39;Input/second&#39;,scale=alt.Scale(type=&#39;log&#39;, scheme=&#39;lightmulti&#39;)) color_condition = alt.condition( alt.datum.values &gt; 1, alt.value(&#39;black&#39;), alt.value(&#39;white&#39;)) MMNIST_Heatmap = heatmap(df_MNIST, &#39;Performance predictions for MNIST&#39;, &#39;red&#39;) text_m = text(df_MNIST, color_condition) MMNIST_Heatmap = MMNIST_Heatmap + text_m alt.vconcat(ImagenetHeatmap, Cifar10Heatmap, MMNIST_Heatmap).resolve_scale(color=&#39;independent&#39;) .",
            "url": "https://rcl-lab.github.io/Qutibench_Web/jupyter/2020/04/02/Rooflines_Altair.html",
            "relUrl": "/jupyter/2020/04/02/Rooflines_Altair.html",
            "date": " • Apr 2, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "MNIST Performance",
            "content": "csv_path = &quot;./data/cleaned_csv/backup.csv&quot; . Rooflines . L3 Performance . Table Statistics . batch/thread/stream lat-comp fps-system fps-comp tp-system tp-comp top1 top5 [%] BasePWR [W] IdlePWR [W] FullPwr [W] GOPS . count | 278.000000 | 278.000000 | 96.000000 | 2.780000e+02 | 96.000000 | 96.000000 | 278.000000 | 0.0 | 278.000000 | 278.000000 | 278.000000 | 0.0 | . mean | 51.384892 | 18.759926 | 2963.662979 | 2.317115e+05 | 7.171515 | 49.448766 | 97.995612 | NaN | 6.498417 | 10.462590 | 12.066345 | NaN | . std | 91.601984 | 51.803819 | 2269.508205 | 6.030472e+05 | 11.967183 | 94.692496 | 0.649877 | NaN | 3.743128 | 5.143244 | 4.489418 | NaN | . min | 1.000000 | 0.002000 | 218.893000 | 1.972737e+01 | 0.043066 | 0.084298 | 96.850000 | NaN | 0.530000 | 1.200000 | 1.548000 | NaN | . 25% | 4.000000 | 0.285652 | 482.129500 | 1.497902e+03 | 0.675684 | 2.056717 | 97.440000 | NaN | 1.800000 | 4.700000 | 9.229500 | NaN | . 50% | 16.000000 | 1.235414 | 2894.530000 | 7.756988e+03 | 2.221820 | 9.825080 | 98.040000 | NaN | 9.200000 | 14.200000 | 14.358750 | NaN | . 75% | 64.000000 | 8.630318 | 5132.930000 | 1.133818e+05 | 8.314235 | 48.249050 | 98.620000 | NaN | 9.200000 | 14.300000 | 15.347606 | NaN | . max | 512.000000 | 435.264000 | 6360.250000 | 3.849624e+06 | 49.608700 | 517.656000 | 98.860000 | NaN | 9.200000 | 14.300000 | 15.775000 | NaN | . Line Plot . Boxplots . Pareto .",
            "url": "https://rcl-lab.github.io/Qutibench_Web/l3/performance/mnist/2020/03/25/MNIST.html",
            "relUrl": "/l3/performance/mnist/2020/03/25/MNIST.html",
            "date": " • Mar 25, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "ImageNet Performance",
            "content": "csv_path = &quot;./data/cleaned_csv/backup.csv&quot; . Roofline . L3 Performance . Table Statistics . batch/thread/stream lat-comp fps-system fps-comp tp-system tp-comp top1 top5 [%] BasePWR [W] IdlePWR [W] FullPwr [W] GOPS PruningFactor norm-lat-comp . count 108.000000 | 108.000000 | 108.000000 | 103.000000 | 108.000000 | 108.000000 | 108.000000 | 108.000000 | 108.000000 | 100.000000 | 108.000000 | 0.0 | 108.000000 | 108.000000 | . mean 14.509259 | 268.169789 | 85.634377 | 120.124102 | 429.990518 | 526.763382 | 71.327311 | 90.373770 | 5.152333 | 8.970120 | 13.537268 | NaN | 84.259259 | 0.084496 | . std 28.698398 | 796.349653 | 79.038255 | 122.346505 | 378.324824 | 432.906072 | 2.887991 | 1.483093 | 6.532648 | 8.976935 | 11.391941 | NaN | 30.492950 | 0.192479 | . min 1.000000 | 2.570470 | 16.936600 | 17.756000 | 98.644084 | 112.536576 | 66.928000 | 87.705800 | 0.253000 | 0.253000 | 0.462000 | NaN | 12.500000 | 0.001783 | . 25% 2.000000 | 22.021050 | 37.291575 | 38.438350 | 180.599256 | 185.100699 | 69.410000 | 89.260000 | 1.800000 | 4.700000 | 8.239317 | NaN | 100.000000 | 0.006964 | . 50% 5.000000 | 68.489050 | 59.201100 | 66.848600 | 282.710500 | 405.891000 | 72.530000 | 90.850000 | 2.500000 | 6.800000 | 8.361605 | NaN | 100.000000 | 0.018346 | . 75% 8.000000 | 176.938500 | 116.282250 | 144.322000 | 543.816500 | 819.351390 | 73.300000 | 91.400000 | 2.500000 | 6.800000 | 11.040000 | NaN | 100.000000 | 0.045650 | . max 128.000000 | 7019.100000 | 379.109000 | 544.702000 | 1496.035640 | 1704.920000 | 75.172000 | 92.118000 | 20.000000 | 29.000000 | 40.600000 | NaN | 100.000000 | 1.000000 | . Line Plot . Boxplots . Pareto .",
            "url": "https://rcl-lab.github.io/Qutibench_Web/l3/performance/imagenet/2020/03/25/ImageNet.html",
            "relUrl": "/l3/performance/imagenet/2020/03/25/ImageNet.html",
            "date": " • Mar 25, 2020"
        }
        
    
  
    
        ,"post4": {
            "title": "CIFAR Performance",
            "content": "csv_path = &quot;./data/cleaned_csv/backup.csv&quot; . Rooflines . L3 Performance . Table Statistics . batch/thread/stream lat-comp fps-system fps-comp tp-system tp-comp top1 top5 [%] BasePWR [W] IdlePWR [W] FullPwr [W] GOPS PruningFactor norm-lat-comp . count 250.000000 | 250.000000 | 96.000000 | 250.000000 | 0.0 | 84.000000 | 250.000000 | 0.0 | 250.000000 | 180.000000 | 250.000000 | 69.000000 | 250.000000 | 250.000000 | . mean 215.136000 | 115.574116 | 1370.634500 | 7263.292764 | NaN | 630.798860 | 81.625760 | NaN | 6.195840 | 7.275000 | 11.461902 | 87.743052 | 40.750000 | 0.007937 | . std 1254.239246 | 929.346956 | 1073.314636 | 11779.292212 | NaN | 484.599296 | 4.429825 | NaN | 3.830652 | 4.196778 | 4.967402 | 564.591429 | 31.006582 | 0.063824 | . min 1.000000 | 0.072000 | 151.555000 | 58.596039 | NaN | 96.317001 | 73.640000 | NaN | 0.530000 | 1.200000 | 1.560000 | 0.008018 | 12.500000 | 0.000005 | . 25% 4.000000 | 1.943957 | 414.847250 | 560.290906 | NaN | 270.065261 | 77.820000 | NaN | 1.800000 | 4.700000 | 7.400000 | 0.475691 | 12.500000 | 0.000134 | . 50% 16.000000 | 8.341500 | 1055.140000 | 1375.970000 | NaN | 462.443938 | 83.250000 | NaN | 9.200000 | 4.700000 | 13.500000 | 1.952694 | 25.000000 | 0.000573 | . 75% 64.000000 | 41.920450 | 2301.155000 | 9689.250000 | NaN | 908.052096 | 85.550000 | NaN | 9.200000 | 11.500000 | 14.825000 | 15.022391 | 50.000000 | 0.002879 | . max 10000.000000 | 14561.129000 | 3631.210000 | 60757.090000 | NaN | 2025.226995 | 88.420000 | NaN | 9.200000 | 12.000000 | 21.357500 | 4694.497280 | 100.000000 | 1.000000 | . Line Plot . Boxplots . Pareto .",
            "url": "https://rcl-lab.github.io/Qutibench_Web/l3/performance/cifar/2020/03/25/CIFAR.html",
            "relUrl": "/l3/performance/cifar/2020/03/25/CIFAR.html",
            "date": " • Mar 25, 2020"
        }
        
    
  
    
        ,"post5": {
            "title": "Initial Data Analysis",
            "content": "Organize . Figure 25 . Note: Don&#39;t have data for left side and missing int4/int2 data for fpga Original: . . maxp_df[&quot;hw_quant_prun&quot;] = maxp_df.apply(lambda r: &quot;_&quot;.join([r.HWType, r.Precision, r.PruningFactor]), axis=1) . /home/zach/anaconda3_v2/lib/python3.7/site-packages/ipykernel_launcher.py:1: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_indexer,col_indexer] = value instead See the caveats in the documentation: http://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy &#34;&#34;&#34;Entry point for launching an IPython kernel. . mlp_df = maxp_df[(maxp_df[&quot;NN_Topology&quot;] == &quot;MLP&quot;)] . mlp_df[&quot;hw_quant_prun&quot;] = mlp_df.apply(lambda r: &quot;_&quot;.join([r.HWType, r.Precision, r.PruningFactor]), axis=1) . /home/zach/anaconda3_v2/lib/python3.7/site-packages/ipykernel_launcher.py:1: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_indexer,col_indexer] = value instead See the caveats in the documentation: http://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy &#34;&#34;&#34;Entry point for launching an IPython kernel. . figa_df = mlp_df[(mlp_df[&quot;HWType&quot;].isin([&quot;NCS&quot;, &quot;ZCU104-Bismo&quot;, &quot;A53-gemmlowp&quot;]))] figb_df = mlp_df[(mlp_df[&quot;HWType&quot;].isin([&quot;GPU&quot;, &quot;ZCU104-FINN&quot;, &quot;A53-gemmlowp&quot;]))] . def select_color(sel, column): return alt.condition(sel, alt.Color(column), alt.value(&#39;lightgray&#39;)) . fig25s = [] fig25_dfs = [figa_df, figb_df] for df in fig25_dfs: sel = alt.selection_multi(fields=[&quot;hw_quant_prun&quot;], bind=&quot;legend&quot;) fig25_dot = alt.Chart(df).mark_point().encode( x=&#39;lat-comp&#39;, y=alt.Y(&#39;fps-comp&#39;, scale=alt.Scale(type=&quot;log&quot;)), color=select_color(sel, &#39;hw_quant_prun:N&#39;), tooltip=[&#39;fps-comp&#39;, &#39;lat-comp&#39;, &#39;HWType&#39;, &#39;batch/thread/stream&#39;], ) fig25_line = alt.Chart(df).mark_line().encode( x=&#39;lat-comp&#39;, y=&#39;fps-comp&#39;, color=select_color(sel, &#39;hw_quant_prun:N&#39;), tooltip=[&#39;fps-comp&#39;, &#39;lat-comp&#39;, &#39;HWType&#39;, &#39;batch/thread/stream&#39;], ) fig = (fig25_dot+fig25_line).properties( title=&quot;Latency versus Performance for Pruned and Quantized MLP Variants&quot;, width=W/len(fig25_dfs), height=H, ).add_selection(sel).interactive() fig25s.append(fig) alt.hconcat(*fig25s) . maxp_df[&quot;quant_model&quot;] = maxp_df.Precision + &#39;_&#39; + maxp_df.HWType . /home/zach/anaconda3_v2/lib/python3.7/site-packages/ipykernel_launcher.py:1: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_indexer,col_indexer] = value instead See the caveats in the documentation: http://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy &#34;&#34;&#34;Entry point for launching an IPython kernel. . def norm_by_group(df, column, group_col): df[&quot;norm-&quot;+column] = df.groupby(group_col)[column].apply(lambda x: (x / x.max())) return df . norm_by_group(maxp_df, &quot;lat-comp&quot;, &quot;NN_Topology&quot;); . /home/zach/anaconda3_v2/lib/python3.7/site-packages/ipykernel_launcher.py:2: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_indexer,col_indexer] = value instead See the caveats in the documentation: http://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy . cnv_df = maxp_df[(maxp_df.NN_Topology == &#39;CNV&#39;) &amp; maxp_df[&#39;norm-lat-comp&#39;].notna()] fig = sns.boxplot(x=&quot;quant_model&quot;, y=&quot;norm-lat-comp&quot;, hue=&quot;PruningFactor&quot;, data=cnv_df) fig.set_title(&quot;latency by chip and net pruning for CNV&quot;) plt.yscale(&quot;log&quot;) plt.xticks(rotation=45) . (array([0, 1, 2, 3, 4, 5, 6, 7, 8]), &lt;a list of 9 Text xticklabel objects&gt;) . TODO:get log axis working for grouped bar . cnv_df[&quot;pf&quot;] = cnv_df.PruningFactor.str.strip(&#39;%&#39;).astype(float) . /home/zach/anaconda3_v2/lib/python3.7/site-packages/ipykernel_launcher.py:1: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_indexer,col_indexer] = value instead See the caveats in the documentation: http://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy &#34;&#34;&#34;Entry point for launching an IPython kernel. . box1 = alt.Chart(cnv_df).mark_boxplot().encode( x=&#39;pf:O&#39;, y=alt.Y(&quot;norm-lat-comp&quot;, scale=alt.Scale(type=&quot;log&quot;)), color=&#39;pf:O&#39; ).facet(column=&quot;quant_model&quot;).properties( title=&quot;Latency by Hardware/Framework and Pruning for CNV&quot; ).interactive() box1 . fig = sns.boxplot(x=&quot;quant_model&quot;, y=&quot;fps-comp&quot;, hue=&quot;PruningFactor&quot;, data=maxp_df[(maxp_df.NN_Topology == &#39;CNV&#39;) &amp; maxp_df[&quot;fps-comp&quot;].notna()]) fig.set_title(&quot;fig 13: FPS by chip and net pruning (CNV)&quot;) plt.yscale(&quot;log&quot;) plt.xticks(rotation=45) . (array([0, 1, 2, 3, 4, 5, 6, 7, 8]), &lt;a list of 9 Text xticklabel objects&gt;) . Paretos . mnist_df = maxp_df[(maxp_df.NN_Topology == &#39;MLP&#39;) &amp; maxp_df[&quot;top1 [%]&quot;].notna()] cifar_df = maxp_df[(maxp_df.NN_Topology == &#39;CNV&#39;) &amp; maxp_df[&quot;top1 [%]&quot;].notna()] imagenet_df = maxp_df[maxp_df.NN_Topology.isin([&#39;GNv1&#39;,&#39;RN50&#39;,&#39;MNv1&#39;]) &amp; maxp_df[&quot;top1 [%]&quot;].notna()] . bad_precisions = [&quot;FP&quot;+str(i) for i in range(17,24)] imagenet_df.Precision = imagenet_df.Precision.apply(lambda x: &#39;FP16&#39; if x in bad_precisions else x) . /home/zach/anaconda3_v2/lib/python3.7/site-packages/pandas/core/generic.py:5208: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_indexer,col_indexer] = value instead See the caveats in the documentation: http://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy self[name] = value . %%writefile utils.py def get_pareto_df(df, groupcol, xcol, ycol): pareto_line_df = df.groupby(groupcol)[xcol].max().to_frame(&quot;x&quot;) pareto_line_df[&#39;y&#39;] = df.groupby(groupcol)[ycol].agg(lambda x: x.value_counts().index[0]) pareto_line_df.sort_values(&#39;y&#39;, ascending=False, inplace=True) pareto_line_df[&#39;x&#39;] = pareto_line_df.x.cummax() pareto_line_df.drop_duplicates(&#39;x&#39;, keep=&#39;first&#39;, inplace=True) pareto_line_df[&#39;group&#39;] = pareto_line_df.index return pareto_line_df def label_point(x, y, val, ax, rot=0): &quot;&quot;&quot; from https://stackoverflow.com/questions/46027653/adding-labels-in-x-y-scatter-plot-with-seaborn&quot;&quot;&quot; a = pd.concat({&#39;x&#39;: x, &#39;y&#39;: y, &#39;val&#39;: val}, axis=1) for i, point in a.iterrows(): ax.text(point[&#39;x&#39;]+.02, point[&#39;y&#39;], str(point[&#39;val&#39;]), rotation=rot) . Writing utils.py . MNIST . sns.set(font_scale=0.8) mnist_pareto = get_pareto_df(mnist_df, &#39;hw_quant_prun&#39;, &#39;fps-comp&#39;, &#39;top1 [%]&#39;) fig, ax = plt.subplots() sns.lineplot(x=&#39;x&#39;, y=&#39;y&#39;, data=mnist_pareto, ax=ax, label=&quot;Pareto Frontier&quot;) ax.lines[0].set_linestyle(&quot;--&quot;) sns.lineplot(x=&#39;fps-comp&#39;, y=&#39;top1 [%]&#39;, hue=&#39;hw_quant_prun&#39;, data=mnist_df, ax=ax) sns.scatterplot(x=&#39;fps-comp&#39;, y=&#39;top1 [%]&#39;, hue=&#39;hw_quant_prun&#39;, data=mnist_df, ax=ax, legend=False) plt.title(&quot;MNIST Cassification Design Space: Accuracy versus Performance&quot;) plt.xlabel(&#39;FPS [hz]&#39;) plt.ylabel(&#39;Top1 Accuracy [%]&#39;) plt.legend(loc=&quot;upper right&quot;, ncol=4) plt.ylim([96, 102]) plt.xlim([-100000, 4800000]) label_point(mnist_pareto.x, mnist_pareto.y, mnist_pareto.group, plt.gca(), 35) . mnist_df.rename(columns={&quot;top1 [%]&quot;: &quot;top1&quot;}, inplace=True) . mnist_lines = alt.Chart(mnist_df).mark_line(point=True).encode( x=&quot;fps-comp&quot;, y=alt.Y(&quot;top1:Q&quot;, scale=alt.Scale(zero=False)), color=alt.Color(&quot;hw_quant_prun&quot;, legend=alt.Legend(columns=2)), tooltip=[&quot;HWType&quot;, &quot;Precision&quot;, &quot;PruningFactor&quot;, &quot;batch/thread/stream&quot;, &quot;top1&quot;, &quot;fps-comp&quot;], ) mnist_pareto_plot = alt.Chart(mnist_pareto).mark_line().encode( x=&quot;x&quot;, y=alt.Y(&quot;y&quot;, scale=alt.Scale(zero=False)), ) (mnist_lines+mnist_pareto_plot).interactive().properties( width=W, height=H, title=&quot;MNIST Cassification Design Space: Accuracy versus Performance&quot; ) . CIFAR . Original: . cifar_pareto = get_pareto_df(cifar_df, &#39;hw_quant_prun&#39;, &#39;fps-comp&#39;, &#39;top1 [%]&#39;) fig, ax = plt.subplots() sns.lineplot(x=&#39;x&#39;, y=&#39;y&#39;, data=cifar_pareto, ax=ax, label=&quot;Pareto Frontier&quot;) ax.lines[0].set_linestyle(&quot;--&quot;) sns.lineplot(x=&#39;fps-comp&#39;, y=&#39;top1 [%]&#39;, hue=&#39;hw_quant_prun&#39;, data=cifar_df, ax=ax) sns.scatterplot(x=&#39;fps-comp&#39;, y=&#39;top1 [%]&#39;, hue=&#39;hw_quant_prun&#39;, data=cifar_df, ax=ax, legend=False) plt.title(&quot;CIFAR 10 Classification Design Space: Accuracy versus Performance&quot;) plt.xlabel(&#39;FPS [hz]&#39;) plt.ylabel(&#39;Top1 Accuracy [%]&#39;) plt.ylim([73, 98]) plt.xlim([0, 80000]) plt.legend(loc=&quot;upper right&quot;, ncol=3) label_point(cifar_pareto.x, cifar_pareto.y, cifar_pareto.group, plt.gca(), 30) . cifar_df.rename(columns={&quot;top1 [%]&quot;: &quot;top1&quot;}, inplace=True) cifar_lines = alt.Chart(cifar_df).mark_line(point=True).encode( x=&quot;fps-comp&quot;, y=alt.Y(&quot;top1:Q&quot;, scale=alt.Scale(zero=False)), color=alt.Color(&quot;hw_quant_prun&quot;, legend=alt.Legend(columns=1)), tooltip=[&quot;HWType&quot;, &quot;Precision&quot;, &quot;PruningFactor&quot;, &quot;batch/thread/stream&quot;, &quot;top1&quot;, &quot;fps-comp&quot;], ) cifar_pareto_plot = alt.Chart(cifar_pareto).mark_line().encode( x=&quot;x&quot;, y=alt.Y(&quot;y&quot;, scale=alt.Scale(zero=False)), ) (cifar_lines+cifar_pareto_plot).interactive().properties( width=W, height=H, title=&quot;CIFAR Cassification Design Space: Accuracy versus Performance&quot; ) . imagenet_df[&quot;hw_precision_net_prun&quot;] = imagenet_df.apply(lambda r: &quot;_&quot;.join([r.HWType, r.Precision, r.NN_Topology, r.PruningFactor]), axis=1) . /home/zach/anaconda3_v2/lib/python3.7/site-packages/ipykernel_launcher.py:1: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_indexer,col_indexer] = value instead See the caveats in the documentation: http://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy &#34;&#34;&#34;Entry point for launching an IPython kernel. . imagenet_pareto = get_pareto_df(imagenet_df, &#39;hw_precision_net_prun&#39;, &#39;fps-comp&#39;, &#39;top1 [%]&#39;) fig, ax = plt.subplots() sns.lineplot(x=&#39;x&#39;, y=&#39;y&#39;, data=imagenet_pareto, ax=ax, label=&quot;Pareto Frontier&quot;) ax.lines[0].set_linestyle(&quot;--&quot;) sns.lineplot(x=&#39;fps-comp&#39;, y=&#39;top1 [%]&#39;, hue=&#39;hw_precision_net_prun&#39;, data=imagenet_df, ax=ax) sns.scatterplot(x=&#39;fps-comp&#39;, y=&#39;top1 [%]&#39;, hue=&#39;hw_precision_net_prun&#39;, data=imagenet_df, ax=ax, legend=False) plt.title(&quot;ImageNet Classification Design Space: Accuracy versus Performance&quot;) plt.xlabel(&#39;FPS [hz]&#39;) plt.ylabel(&#39;Top1 Accuracy [%]&#39;) plt.ylim([66, 79]) plt.xlim([0, 750]) plt.legend(loc=&quot;upper right&quot;, ncol=2) label_point(imagenet_pareto.x, imagenet_pareto.y, imagenet_pareto.group, plt.gca(), 15) . posx and posy should be finite values posx and posy should be finite values posx and posy should be finite values . imagenet_df.rename(columns={&quot;top1 [%]&quot;: &quot;top1&quot;}, inplace=True) imagenet_lines = alt.Chart(imagenet_df).mark_line(point=True).encode( x=&quot;fps-comp&quot;, y=alt.Y(&quot;top1:Q&quot;, scale=alt.Scale(zero=False)), color=alt.Color(&quot;hw_precision_net_prun&quot;, legend=alt.Legend(columns=1)), tooltip=[&quot;HWType&quot;, &quot;Precision&quot;, &quot;PruningFactor&quot;, &quot;batch/thread/stream&quot;, &quot;top1&quot;, &quot;fps-comp&quot;], ) imagenet_pareto_plot = alt.Chart(imagenet_pareto).mark_line().encode( x=&quot;x&quot;, y=alt.Y(&quot;y&quot;, scale=alt.Scale(zero=False)), ) (imagenet_lines+imagenet_pareto_plot).interactive().properties( width=W, height=H, title=&quot;ImageNet Cassification Design Space: Accuracy versus Performance&quot; ) .",
            "url": "https://rcl-lab.github.io/Qutibench_Web/jupyter/2020/03/13/Convert-to-Altair.html",
            "relUrl": "/jupyter/2020/03/13/Convert-to-Altair.html",
            "date": " • Mar 13, 2020"
        }
        
    
  
    
        ,"post6": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master- badges: true- comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . #collapse-hide import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . #collapse-show cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # single-value selection over [Major_Genre, MPAA_Rating] pairs # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(movies).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(movies).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=alt.Y(&#39;IMDB_Rating:Q&#39;, axis=alt.Axis(minExtent=30)), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=600, height=400 ) . Example 3: More Tooltips . # select a point for which to provide details-on-demand label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=700, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; df = pd.read_json(movies) # display table with pandas df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://rcl-lab.github.io/Qutibench_Web/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post7": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://rcl-lab.github.io/Qutibench_Web/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  
    
        ,"post8": {
            "title": "Performance Template Notebook",
            "content": "TODO . Remove cells that filter dataframe | Rename dataframe and only use one | Break up original 3 benchmarks data | Add requirements.txt file | . Rooflines . L3 Performance . Table Statistics . batch/thread/stream lat-comp fps-system fps-comp tp-system tp-comp top1 top5 [%] BasePWR [W] IdlePWR [W] FullPwr [W] GOPS . count 278.000000 | 278.000000 | 96.000000 | 2.780000e+02 | 96.000000 | 96.000000 | 278.000000 | 0.0 | 278.000000 | 278.000000 | 278.000000 | 0.0 | . mean 51.384892 | 18.759926 | 2963.662979 | 2.317115e+05 | 7.171515 | 49.448766 | 97.995612 | NaN | 6.498417 | 10.462590 | 12.066345 | NaN | . std 91.601984 | 51.803819 | 2269.508205 | 6.030472e+05 | 11.967183 | 94.692496 | 0.649877 | NaN | 3.743128 | 5.143244 | 4.489418 | NaN | . min 1.000000 | 0.002000 | 218.893000 | 1.972737e+01 | 0.043066 | 0.084298 | 96.850000 | NaN | 0.530000 | 1.200000 | 1.548000 | NaN | . 25% 4.000000 | 0.285652 | 482.129500 | 1.497902e+03 | 0.675684 | 2.056717 | 97.440000 | NaN | 1.800000 | 4.700000 | 9.229500 | NaN | . 50% 16.000000 | 1.235414 | 2894.530000 | 7.756988e+03 | 2.221820 | 9.825080 | 98.040000 | NaN | 9.200000 | 14.200000 | 14.358750 | NaN | . 75% 64.000000 | 8.630318 | 5132.930000 | 1.133818e+05 | 8.314235 | 48.249050 | 98.620000 | NaN | 9.200000 | 14.300000 | 15.347606 | NaN | . max 512.000000 | 435.264000 | 6360.250000 | 3.849624e+06 | 49.608700 | 517.656000 | 98.860000 | NaN | 9.200000 | 14.300000 | 15.775000 | NaN | . Line Plot . Boxplots . Pareto .",
            "url": "https://rcl-lab.github.io/Qutibench_Web/2020/01/01/Jupyter_benchmark_template.html",
            "relUrl": "/2020/01/01/Jupyter_benchmark_template.html",
            "date": " • Jan 1, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This is where you put the contents of your About page. Like all your pages, it’s in Markdown format. . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://rcl-lab.github.io/Qutibench_Web/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://rcl-lab.github.io/Qutibench_Web/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}